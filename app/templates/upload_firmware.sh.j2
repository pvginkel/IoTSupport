#!/bin/sh
# IoT Support Firmware Upload Script
# Generated by {{ backend_url }}/api/pipeline/upload.sh
#
# Usage: curl -fsSL {{ backend_url }}/api/pipeline/upload.sh | sh -s -- [model_code] [firmware.bin]
#
# Arguments are optional - if omitted, they are inferred from build/project_description.json
#
# Environment variables:
#   IOTSUPPORT_CLIENT_ID     - OAuth2 client ID with pipeline role (required)
#   IOTSUPPORT_CLIENT_SECRET - OAuth2 client secret (required)

set -e

# Baked-in configuration from server
BACKEND_URL="{{ backend_url }}"
TOKEN_URL="{{ token_url }}"

# Parse arguments (optional - will auto-detect from ESP-IDF project if omitted)
MODEL_CODE="$1"
FIRMWARE_FILE="$2"

# Auto-detect from ESP-IDF project description if arguments not provided
PROJECT_DESC="build/project_description.json"
if [ -z "$MODEL_CODE" ] || [ -z "$FIRMWARE_FILE" ]; then
    if [ ! -f "$PROJECT_DESC" ]; then
        echo "Error: No arguments provided and $PROJECT_DESC not found" >&2
        echo "Usage: $0 [model_code] [firmware.bin]" >&2
        echo "Run from ESP-IDF project root, or provide arguments explicitly" >&2
        exit 1
    fi

    # Extract project_name from JSON
    if command -v jq >/dev/null 2>&1; then
        PROJECT_NAME=$(jq -r '.project_name' "$PROJECT_DESC")
    else
        PROJECT_NAME=$(grep -o '"project_name"[[:space:]]*:[[:space:]]*"[^"]*"' "$PROJECT_DESC" | sed 's/.*"project_name"[[:space:]]*:[[:space:]]*"//;s/"$//')
    fi

    if [ -z "$PROJECT_NAME" ]; then
        echo "Error: Could not extract project_name from $PROJECT_DESC" >&2
        exit 1
    fi

    # Use extracted values if not provided as arguments
    MODEL_CODE="${MODEL_CODE:-$PROJECT_NAME}"
    FIRMWARE_FILE="${FIRMWARE_FILE:-build/${PROJECT_NAME}.bin}"

    echo "Auto-detected from $PROJECT_DESC: model=$MODEL_CODE, file=$FIRMWARE_FILE"
fi

if [ ! -f "$FIRMWARE_FILE" ]; then
    echo "Error: Firmware file not found: $FIRMWARE_FILE" >&2
    exit 1
fi

# Validate required environment variables
if [ -z "$IOTSUPPORT_CLIENT_ID" ]; then
    echo "Error: IOTSUPPORT_CLIENT_ID environment variable is required" >&2
    exit 1
fi

if [ -z "$IOTSUPPORT_CLIENT_SECRET" ]; then
    echo "Error: IOTSUPPORT_CLIENT_SECRET environment variable is required" >&2
    exit 1
fi

if [ -z "$TOKEN_URL" ]; then
    echo "Error: Server did not provide token URL (OIDC not configured)" >&2
    exit 1
fi

# Derive paths for companion build artifacts
BUILD_DIR=$(dirname "$FIRMWARE_FILE")
BIN_BASENAME=$(basename "$FIRMWARE_FILE" .bin)
ELF_FILE="${BUILD_DIR}/${BIN_BASENAME}.elf"
MAP_FILE="${BUILD_DIR}/${BIN_BASENAME}.map"
SDKCONFIG_FILE="sdkconfig"

# Verify all ZIP artifacts are present
MISSING=""
for f in "$ELF_FILE" "$MAP_FILE" "$SDKCONFIG_FILE"; do
    if [ ! -f "$f" ]; then
        MISSING="$MISSING $f"
    fi
done

if [ -n "$MISSING" ]; then
    echo "Error: Missing required build artifacts:$MISSING" >&2
    echo "Ensure the project has been built and all artifacts (.elf, .map, sdkconfig) are present." >&2
    exit 1
fi

if ! command -v zip >/dev/null 2>&1; then
    echo "Error: 'zip' command is required but not found. Please install it." >&2
    exit 1
fi

# Get OAuth2 access token
echo "Authenticating with $TOKEN_URL..."
TOKEN_RESPONSE=$(curl -fsSL -X POST "$TOKEN_URL" \
    -d "grant_type=client_credentials" \
    -d "client_id=$IOTSUPPORT_CLIENT_ID" \
    -d "client_secret=$IOTSUPPORT_CLIENT_SECRET")

# Extract access token (works with jq if available, falls back to grep/sed)
if command -v jq >/dev/null 2>&1; then
    ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.access_token')
else
    ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | grep -o '"access_token":"[^"]*"' | sed 's/"access_token":"//;s/"$//')
fi

if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" = "null" ]; then
    echo "Error: Failed to obtain access token" >&2
    echo "Response: $TOKEN_RESPONSE" >&2
    exit 1
fi

# Package as ZIP with all build artifacts
echo "Packaging firmware ZIP for model $MODEL_CODE..."

# Extract firmware version from the binary for version.json
# The version string is at offset 48 in the binary (after 24-byte image header,
# 8-byte segment header, and 16 bytes into AppInfo)
FW_VERSION=$(strings -t d "$FIRMWARE_FILE" 2>/dev/null | awk '$1 >= 48 && $1 < 80 {print $2; exit}' || echo "unknown")

# Get git commit hash
GIT_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "unknown")

# Get IDF version from build metadata or environment
IDF_VERSION="${IDF_VERSION:-$(idf.py --version 2>/dev/null || echo "unknown")}"

# Generate version.json
TEMP_DIR=$(mktemp -d)
trap 'rm -rf "$TEMP_DIR"' EXIT

cat > "${TEMP_DIR}/version.json" <<VJEOF
{
    "git_commit": "$GIT_COMMIT",
    "idf_version": "$IDF_VERSION",
    "firmware_version": "$FW_VERSION"
}
VJEOF

# Create ZIP with required files
ZIP_FILE="${TEMP_DIR}/firmware.zip"
zip -j "$ZIP_FILE" \
    "$FIRMWARE_FILE" \
    "$ELF_FILE" \
    "$MAP_FILE" \
    "$SDKCONFIG_FILE" \
    "${TEMP_DIR}/version.json"

echo "Uploading firmware ZIP to model $MODEL_CODE..."
UPLOAD_RESPONSE=$(curl -fsSL -X POST "$BACKEND_URL/api/pipeline/models/$MODEL_CODE/firmware" \
    -H "Authorization: Bearer $ACCESS_TOKEN" \
    -H "Content-Type: application/octet-stream" \
    --data-binary "@$ZIP_FILE")

# Extract version from response
if command -v jq >/dev/null 2>&1; then
    VERSION=$(echo "$UPLOAD_RESPONSE" | jq -r '.firmware_version // empty')
else
    VERSION=$(echo "$UPLOAD_RESPONSE" | grep -o '"firmware_version":"[^"]*"' | sed 's/"firmware_version":"//;s/"$//' || true)
fi

if [ -n "$VERSION" ]; then
    echo "Success: Uploaded firmware version $VERSION"
else
    echo "Success: Firmware uploaded"
    echo "Response: $UPLOAD_RESPONSE"
fi
